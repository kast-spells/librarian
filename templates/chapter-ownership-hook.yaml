{{/*kast - Kubernetes arcane spelling technology
Copyright (C) 2023 namenmalkv@gmail.com
Licensed under the GNU GPL v3. See LICENSE file for details.
*/}}

{{- $spellbook :=  dict "appParams" $.Values.appParams  }}
{{- $_ := set $spellbook "name" (default $.Release.Name $.Values.name) }}

{{- $path := printf "bookrack/%s/index.yaml" (default .Release.Name .Values.name) }}
{{- if .Files.Glob $path }}
  {{- $default := .Files.Get $path | fromYaml }}
  {{- $_ := mergeOverwrite $spellbook $default }}
{{- end }}

{{/* RBAC Resources - created once for all chapters */}}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chapter-ownership-hook
  namespace: {{ default "argocd" $spellbook.argocdNamespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "-10"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: chapter-ownership-hook
  namespace: {{ default "argocd" $spellbook.argocdNamespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "-10"
rules:
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list", "patch"]
  - apiGroups: ["argoproj.io"]
    resources: ["applications"]
    verbs: ["get", "list", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: chapter-ownership-hook
  namespace: {{ default "argocd" $spellbook.argocdNamespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "-10"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: chapter-ownership-hook
subjects:
  - kind: ServiceAccount
    name: chapter-ownership-hook
    namespace: {{ default "argocd" $spellbook.argocdNamespace }}

{{/* Hook Job - one per chapter */}}
{{ range $chapterName := $spellbook.chapters }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: set-ownership-{{ $spellbook.name }}-{{ $chapterName }}-{{ now | date "20060102-150405" }}
  namespace: {{ default "argocd" $spellbook.argocdNamespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    # argocd.argoproj.io/hook-delete-policy: HookSucceeded  # Disabled to keep jobs for log inspection
    argocd.argoproj.io/sync-wave: "10"
  labels:
    kast.spells/book: {{ $spellbook.name }}
    kast.spells/chapter: {{ $chapterName }}
    kast.spells/hook-type: ownership
spec:
  # ttlSecondsAfterFinished: 300  # Commented out to keep jobs for debugging
  backoffLimit: 3
  template:
    metadata:
      labels:
        kast.spells/book: {{ $spellbook.name }}
        kast.spells/chapter: {{ $chapterName }}
    spec:
      serviceAccountName: chapter-ownership-hook
      restartPolicy: OnFailure
      containers:
      - name: set-ownership
        image: alpine/k8s:1.31.4
        command: ["/bin/sh"]
        args:
          - -c
          - |
            set -e

            CHAPTER="{{ $chapterName }}"
            BOOK="{{ $spellbook.name }}"
            NAMESPACE="{{ default "argocd" $spellbook.argocdNamespace }}"
            CONFIGMAP_NAME="chapter-${BOOK}-${CHAPTER}"
            BOOK_APP_NAME="${BOOK}-book"

            echo "========================================"
            echo "Chapter Ownership Hook"
            echo "========================================"
            echo "Book:           $BOOK"
            echo "Chapter:        $CHAPTER"
            echo "Book App:       $BOOK_APP_NAME"
            echo "Chapter ConfigMap: $CONFIGMAP_NAME"
            echo ""

            # STEP 1: Get Book Application UID
            echo "========================================"
            echo "STEP 1: Get Book Application UID"
            echo "========================================"
            
            if ! kubectl get application "$BOOK_APP_NAME" -n "$NAMESPACE" &>/dev/null; then
              echo "ERROR: Book Application '$BOOK_APP_NAME' not found"
              echo "This hook must run AFTER the book Application is created"
              exit 1
            fi

            BOOK_APP_UID=$(kubectl get application "$BOOK_APP_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.uid}')
            
            if [ -z "$BOOK_APP_UID" ]; then
              echo "ERROR: Failed to get Book Application UID"
              exit 1
            fi

            echo "‚úì Book Application: $BOOK_APP_NAME"
            echo "‚úì Book App UID: $BOOK_APP_UID"

            # STEP 2: Wait for ConfigMap and get its UID
            echo ""
            echo "========================================"
            echo "STEP 2: Get Chapter ConfigMap UID"
            echo "========================================"
            
            MAX_WAIT=30
            WAITED=0
            while [ $WAITED -lt $MAX_WAIT ]; do
              if kubectl get configmap "$CONFIGMAP_NAME" -n "$NAMESPACE" &>/dev/null; then
                echo "‚úì ConfigMap exists"
                break
              fi
              sleep 2
              WAITED=$((WAITED + 2))
            done

            if [ $WAITED -ge $MAX_WAIT ]; then
              echo "ERROR: ConfigMap $CONFIGMAP_NAME not found after ${MAX_WAIT}s"
              exit 1
            fi

            CM_UID=$(kubectl get configmap "$CONFIGMAP_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.uid}')

            if [ -z "$CM_UID" ]; then
              echo "ERROR: Failed to get ConfigMap UID"
              exit 1
            fi

            echo "‚úì ConfigMap: $CONFIGMAP_NAME"
            echo "‚úì ConfigMap UID: $CM_UID"

            # STEP 3: Patch ConfigMap with ownerReference to Book Application
            echo ""
            echo "========================================"
            echo "STEP 3: Patch ConfigMap Ownership"
            echo "========================================"
            
            # Check if ConfigMap already has ownerReference to book
            EXISTING_CM_OWNER=$(kubectl get configmap "$CONFIGMAP_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.ownerReferences[?(@.kind=="Application")].name}' 2>/dev/null || true)

            if [ "$EXISTING_CM_OWNER" = "$BOOK_APP_NAME" ]; then
              echo "‚äô ConfigMap already has ownerReference to $BOOK_APP_NAME - skipping"
            else
              echo "Adding ownerReference to ConfigMap..."
              
              # Use strategic merge patch (more robust than JSON patch)
              if kubectl patch configmap "$CONFIGMAP_NAME" -n "$NAMESPACE" --type=merge -p "{
                \"metadata\": {
                  \"ownerReferences\": [{
                    \"apiVersion\": \"argoproj.io/v1alpha1\",
                    \"kind\": \"Application\",
                    \"name\": \"$BOOK_APP_NAME\",
                    \"uid\": \"$BOOK_APP_UID\",
                    \"controller\": false,
                    \"blockOwnerDeletion\": true
                  }]
                }
              }" 2>&1; then
                echo "‚úì ConfigMap ownerReference added successfully"
              else
                echo "‚úó Failed to patch ConfigMap"
                exit 1
              fi
            fi

            # STEP 4: Find and patch Applications
            echo ""
            echo "========================================"
            echo "STEP 4: Patch Applications Ownership"
            echo "========================================"
            
            APPS=$(kubectl get applications -n "$NAMESPACE" -l "kast.spells/chapter=${CHAPTER}" -o name 2>/dev/null || true)

            if [ -z "$APPS" ]; then
              echo "‚ö† No Applications found for chapter $CHAPTER"
              echo "This is OK if chapter has no spells yet"
              exit 0
            fi

            APP_COUNT=$(echo "$APPS" | wc -l)
            echo "Found $APP_COUNT Application(s) in chapter"
            echo ""

            # Use temp file to avoid subshell variable scope issues
            RESULTS_FILE=$(mktemp)
            echo "0" > "$RESULTS_FILE.success"
            echo "0" > "$RESULTS_FILE.failed"
            echo "0" > "$RESULTS_FILE.skipped"

            echo "$APPS" | while IFS= read -r APP; do
              APP_NAME=$(echo "$APP" | cut -d'/' -f2)
              echo "Processing: $APP_NAME"

              # Check if ownerReference already exists
              EXISTING_OWNER=$(kubectl get "$APP" -n "$NAMESPACE" -o jsonpath='{.metadata.ownerReferences[?(@.kind=="ConfigMap")].name}' 2>/dev/null || true)

              if [ "$EXISTING_OWNER" = "$CONFIGMAP_NAME" ]; then
                echo "  ‚äô Already has correct ownerReference - skipping"
                SKIPPED=$(cat "$RESULTS_FILE.skipped")
                echo $((SKIPPED + 1)) > "$RESULTS_FILE.skipped"
                continue
              fi

              # Use strategic merge patch (more robust)
              if kubectl patch "$APP" -n "$NAMESPACE" --type=merge -p "{
                \"metadata\": {
                  \"ownerReferences\": [{
                    \"apiVersion\": \"v1\",
                    \"kind\": \"ConfigMap\",
                    \"name\": \"$CONFIGMAP_NAME\",
                    \"uid\": \"$CM_UID\",
                    \"controller\": false,
                    \"blockOwnerDeletion\": true
                  }]
                }
              }" >/dev/null 2>&1; then
                echo "  ‚úì ownerReference added"
                
                # CRITICAL: Remove tracking-id to force ArgoCD to use ownerReferences for UI tree
                # This recreates the "cache failure" state where hierarchy worked correctly
                echo "  ‚ö° Removing tracking-id annotation to enable ownerReference-based hierarchy..."
                if kubectl annotate "$APP" -n "$NAMESPACE" \
                  argocd.argoproj.io/tracking-id- \
                  --overwrite >/dev/null 2>&1; then
                  echo "  ‚úì tracking-id removed (ArgoCD will now use ownerReferences for UI tree)"
                else
                  echo "  ‚ö† Failed to remove tracking-id (non-critical, hierarchy may not work)"
                fi
                
                SUCCESS=$(cat "$RESULTS_FILE.success")
                echo $((SUCCESS + 1)) > "$RESULTS_FILE.success"
              else
                echo "  ‚úó Failed to patch"
                FAILED=$(cat "$RESULTS_FILE.failed")
                echo $((FAILED + 1)) > "$RESULTS_FILE.failed"
              fi
            done

            # Read final counts from temp files
            SUCCESS=$(cat "$RESULTS_FILE.success")
            FAILED=$(cat "$RESULTS_FILE.failed")
            SKIPPED=$(cat "$RESULTS_FILE.skipped")
            
            # Cleanup temp files
            rm -f "$RESULTS_FILE" "$RESULTS_FILE.success" "$RESULTS_FILE.failed" "$RESULTS_FILE.skipped"

            # Summary
            echo ""
            echo "========================================"
            echo "Summary"
            echo "========================================"
            echo "Book Application:    $BOOK_APP_NAME ‚úì"
            echo "Chapter ConfigMap:   $CONFIGMAP_NAME ‚úì"
            echo ""
            echo "Total Applications:  $APP_COUNT"
            echo "  Success:           $SUCCESS"
            echo "  Skipped:           $SKIPPED (already had ownerReference)"
            echo "  Failed:            $FAILED"
            echo ""

            if [ "$FAILED" -gt 0 ]; then
              echo "‚ö† Some Applications failed to patch"
              exit 1
            fi

            echo "‚úì All ownership references configured successfully"
            echo "‚úì Tracking-IDs removed from child Applications"
            echo ""
            echo "üìä Expected ArgoCD UI hierarchy:"
            echo "   $BOOK_APP_NAME (Application)"
            echo "     ‚îî‚îÄ $CONFIGMAP_NAME (ConfigMap)"
            echo "        ‚îî‚îÄ Applications (via ownerReferences)"
            echo ""
            echo "‚ö†Ô∏è  Note: Child Applications no longer tracked by $BOOK_APP_NAME"
            echo "    They will sync/prune independently but ownership is preserved for garbage collection"
{{- end }}
